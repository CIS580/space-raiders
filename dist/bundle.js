/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/resources/planet_player/PlanetPlayer.json":
/*!********************************************************!*\
  !*** ./dist/resources/planet_player/PlanetPlayer.json ***!
  \********************************************************/
/*! exports provided: columns, image, imageheight, imagewidth, margin, name, spacing, tilecount, tiledversion, tileheight, tilewidth, type, version, default */
/***/ (function(module) {

eval("module.exports = {\"columns\":3,\"image\":\"astrogun.png\",\"imageheight\":128,\"imagewidth\":96,\"margin\":0,\"name\":\"AstroGun\",\"spacing\":0,\"tilecount\":12,\"tiledversion\":\"1.2.1\",\"tileheight\":32,\"tilewidth\":32,\"type\":\"tileset\",\"version\":1.2};\n\n//# sourceURL=webpack:///./dist/resources/planet_player/PlanetPlayer.json?");

/***/ }),

/***/ "./dist/resources/planet_tilesets/sample_planet_level/tilemap.json":
/*!*************************************************************************!*\
  !*** ./dist/resources/planet_tilesets/sample_planet_level/tilemap.json ***!
  \*************************************************************************/
/*! exports provided: height, infinite, layers, nextlayerid, nextobjectid, orientation, renderorder, tiledversion, tileheight, tilesets, tilewidth, type, version, width, default */
/***/ (function(module) {

eval("module.exports = {\"height\":24,\"infinite\":false,\"layers\":[{\"data\":[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,6,6,6,6,6,6,6,2,2,2,2,2,2,2,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,6,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,6,6,2,2,6,6,6,6,6,6,5,5,5,5,5,6,2,2,2,2,2,2,2,2,2,3,3,3,3,3,2,2,2,2,2,2,2,2,2,6,6,6,6,5,5,5,6,6,2,2,3,3,3,3,3,3,3,3,1,1,3,3,3,3,3,3,3,4,2,2,2,2,2,6,6,5,5,5,6,6,2,2,3,3,3,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,6,6,5,5,6,6,2,2,3,3,1,4,4,1,1,3,3,2,2,2,2,2,2,2,3,3,3,1,1,3,2,2,6,6,5,5,6,2,2,2,3,1,1,4,4,3,3,3,2,2,6,6,6,6,6,2,2,3,1,4,1,1,3,2,2,6,5,5,6,2,2,2,3,1,1,3,3,2,2,2,2,6,6,6,6,6,6,6,2,3,1,1,1,1,3,2,2,6,5,5,6,2,2,2,3,4,1,3,3,2,2,6,6,6,6,2,2,2,6,6,6,2,3,1,1,1,3,2,2,6,5,5,6,6,2,2,3,3,3,2,2,2,6,6,6,6,2,2,3,2,2,2,2,2,3,1,4,4,3,2,2,6,5,5,6,6,2,2,2,2,2,2,6,6,6,6,6,6,2,3,3,3,3,2,2,3,3,1,4,4,3,3,2,6,5,5,5,6,2,2,2,2,2,2,6,6,6,6,6,2,2,3,3,1,3,3,3,3,1,1,1,1,3,2,2,6,5,5,5,6,6,2,2,4,2,2,2,6,6,6,6,2,3,3,3,4,4,1,1,1,1,1,3,3,3,2,2,6,5,5,6,6,6,2,2,2,2,2,2,6,6,6,6,2,2,3,3,4,4,1,1,1,1,3,3,3,2,2,6,6,5,5,6,6,6,6,2,2,2,2,6,6,6,6,6,2,2,3,3,1,3,3,3,3,3,3,3,2,2,6,6,6,5,5,5,5,5,6,6,2,2,6,6,6,5,6,6,6,2,2,3,3,3,2,2,2,2,2,2,2,6,6,6,5,5,5,5,5,5,6,6,6,6,6,5,5,5,5,6,6,6,2,2,2,2,2,2,2,2,2,6,6,6,6,5,5,5,5,5,5,5,5,5,5,6,6,5,5,5,5,6,6,6,6,6,2,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],\"height\":24,\"id\":1,\"name\":\"Tile Layer 1\",\"opacity\":1,\"type\":\"tilelayer\",\"visible\":true,\"width\":32,\"x\":0,\"y\":0}],\"nextlayerid\":2,\"nextobjectid\":1,\"orientation\":\"orthogonal\",\"renderorder\":\"right-down\",\"tiledversion\":\"1.2.0\",\"tileheight\":32,\"tilesets\":[{\"firstgid\":1,\"source\":\"tileset.tsx\"}],\"tilewidth\":32,\"type\":\"map\",\"version\":1.2,\"width\":32};\n\n//# sourceURL=webpack:///./dist/resources/planet_tilesets/sample_planet_level/tilemap.json?");

/***/ }),

/***/ "./dist/resources/planet_tilesets/sample_planet_level/tileset.json":
/*!*************************************************************************!*\
  !*** ./dist/resources/planet_tilesets/sample_planet_level/tileset.json ***!
  \*************************************************************************/
/*! exports provided: columns, image, imageheight, imagewidth, margin, name, spacing, tilecount, tiledversion, tileheight, tiles, tilewidth, type, version, default */
/***/ (function(module) {

eval("module.exports = {\"columns\":4,\"image\":\"tiles.png\",\"imageheight\":128,\"imagewidth\":128,\"margin\":0,\"name\":\"tileset\",\"spacing\":0,\"tilecount\":16,\"tiledversion\":\"1.2.0\",\"tileheight\":32,\"tiles\":[{\"id\":0,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":true},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":1,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":true},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":2,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":true},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":3,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":4,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":true}]},{\"id\":5,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":true},{\"name\":\"water\",\"type\":\"bool\",\"value\":true}]},{\"id\":6,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":7,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":8,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":9,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":10,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":11,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":12,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":13,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":14,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]},{\"id\":15,\"properties\":[{\"name\":\"passable\",\"type\":\"bool\",\"value\":false},{\"name\":\"water\",\"type\":\"bool\",\"value\":false}]}],\"tilewidth\":32,\"type\":\"tileset\",\"version\":1.2};\n\n//# sourceURL=webpack:///./dist/resources/planet_tilesets/sample_planet_level/tileset.json?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/index.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/index.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"body, canvas {\\r\\n  padding: 0;\\r\\n  margin: 0;\\r\\n  border: 0;\\r\\n}\\r\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/index.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./src/PlanetPlayer.js":
/*!*****************************!*\
  !*** ./src/PlanetPlayer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PlanetPlayer; });\n/**\r\n * Represents the player, including location.\r\n * Health functionality could be added here, as long as it doesn't conflict with other levels that might not use it.\r\n * The player is typically created and managed by the PlanetLevelManager, so avoid creating players in your own game.\r\n */\r\nclass PlanetPlayer {\r\n\r\n  /**\r\n   * Create the player for a specific level.\r\n   * Loads the player animation images.\r\n   * @param {BasePlanetLevel} level - The level this player belongs to.\r\n   */\r\n  constructor(level) {\r\n    this.level = level;\r\n\r\n    this.animationDuration = 150;\r\n    this.animationMsPerImage = 100;\r\n\r\n    this.animationXOffset = 0;\r\n    this.animationYOffset = 0;\r\n    this.animationDirection = 0;\r\n    this.animationXOffset = 0;\r\n    this.animationYOffset = 0;\r\n    this.animationTimer = 0;\r\n    this.animationImageSequence = 0;\r\n    this.animationImageTile = undefined;\r\n\r\n    this.movePlayerToSpawn();\r\n\r\n    this.imagesLoading = 2;\r\n    this.playerJson = __webpack_require__(/*! ../dist/resources/planet_player/PlanetPlayer.json */ \"./dist/resources/planet_player/PlanetPlayer.json\");\r\n\r\n    // Load the tileset image.\r\n    this.gunImage = new Image();\r\n    this.noGunImage = new Image();\r\n\r\n    this.gunImage.onload = (() => {\r\n      this.imagesLoading--;\r\n    });\r\n\r\n    this.noGunImage.onload = (() => {\r\n      this.imagesLoading--;\r\n    });\r\n\r\n    this.gunImage.src = \"resources/planet_player/astrogun.png\";\r\n    this.noGunImage.src = \"resources/planet_player/astroman.png\";\r\n\r\n    /// Load the tileset. Create an array of properties for each tile type which can be easily queried.\r\n    this.tileset = [];\r\n    for(let i = 0; i < this.playerJson.tilecount; i++) {\r\n      let properties = [];\r\n      properties[\"id\"] = i;\r\n      properties[\"imageX\"] = this.playerJson.spacing + ((i % this.playerJson.columns) * (32 + this.playerJson.margin));\r\n      properties[\"imageY\"] = this.playerJson.spacing + (Math.floor(i / this.playerJson.columns) * (32 + this.playerJson.margin));\r\n\r\n      this.tileset[i] = properties;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move the player to a specific location and direction.\r\n   * @param x - New grid x position.\r\n   * @param y - New grid y position.\r\n   * @param direction - New face direction integer. If omitted, the face direction won't change.\r\n   * Face direction key:\r\n   *     N       0       -y\r\n   *   W   E   1   3   -x  +x\r\n   *     S       2       +y\r\n   */\r\n  movePlayer(x, y, direction) {\r\n    this.x = x;\r\n    this.y = y;\r\n    if(direction !== undefined && direction !== null) {\r\n      this.faceDirection = direction;\r\n    }\r\n    this.level.playerMoved(this);\r\n  }\r\n\r\n  /**\r\n   * Move the player to the spawn location, as if it was killed and is re-spawning.\r\n   */\r\n  movePlayerToSpawn() {\r\n    this.movePlayer(this.level.playerSpawnX, this.level.playerSpawnY, this.level.playerSpawnFaceDirection);\r\n  }\r\n\r\n  /** @method\r\n   * Update logic related to player.\r\n   * @param {DOMHighResTimeStamp} elaspedTime - The amount of time elapsed this frame.\r\n   * @param {Input} input - The input from this and the prior frame.\r\n   * @param {Game} game - The game object. Not currently used.\r\n   */\r\n  update(elaspedTime, input, game) {\r\n    let moveLeft = input.keyPressed('ArrowLeft') || false;\r\n    let moveRight = input.keyPressed('ArrowRight') || false;\r\n    let moveUp = input.keyPressed('ArrowUp') || false;\r\n    let moveDown = input.keyPressed('ArrowDown') || false;\r\n    let interact = input.keyDown('f') || false;\r\n    let fire = input.keyDown(' ') || false;\r\n\r\n    if(this.animationTimer > 0) {\r\n      this.animationTimer -= elaspedTime;\r\n      this.animationImageSequence += elaspedTime;\r\n\r\n      if(this.animationTimer <= 0) {\r\n        this.animationXOffset = 0;\r\n        this.animationYOffset = 0;\r\n        if(this.animationDirection % 2 === 0) {\r\n          this.y += this.animationDirection - 1;\r\n        } else {\r\n          this.x += this.animationDirection - 2;\r\n        }\r\n\r\n        this.level.playerMoved(this);\r\n      } else {\r\n        if(this.animationDirection % 2 === 0) { // north or south\r\n          this.animationYOffset = (this.animationDirection - 1) * (32 - (32 * (this.animationTimer / this.animationDuration)));\r\n        } else {\r\n          this.animationXOffset = (this.animationDirection - 2) * (32 - (32 * (this.animationTimer / this.animationDuration)));\r\n        }\r\n      }\r\n    }\r\n\r\n    // If more than one button is pressed down, we won't move.\r\n    // This is to prevent some uncertain movement when the player is spamming the keys.\r\n\r\n    // Asks the level if the target tile is passable before moving there.\r\n    // Face direction will change regardless if the tile is passable.\r\n\r\n    if(this.animationTimer <= 0) {\r\n      if(moveLeft + moveRight + moveUp + moveDown === 1) {\r\n        if(moveLeft) {\r\n          this.faceDirection = 1;\r\n          if(this.level.tilePassable(this.x - 1, this.y)) {\r\n            this.animationTimer += this.animationDuration;\r\n            this.animationDirection = this.faceDirection;\r\n          }\r\n        } else if (moveRight) {\r\n          this.faceDirection = 3;\r\n          if(this.level.tilePassable(this.x + 1, this.y)) {\r\n            this.animationTimer += this.animationDuration;\r\n            this.animationDirection = this.faceDirection;\r\n          }\r\n        } else if (moveUp) {\r\n          this.faceDirection = 0;\r\n          if(this.level.tilePassable(this.x, this.y - 1)) {\r\n            this.animationTimer += this.animationDuration;\r\n            this.animationDirection = this.faceDirection;\r\n          }\r\n        } else if (moveDown) {\r\n          this.faceDirection = 2;\r\n          if(this.level.tilePassable(this.x, this.y + 1)) {\r\n            this.animationTimer += this.animationDuration;\r\n            this.animationDirection = this.faceDirection;\r\n          }\r\n        }\r\n      } else {\r\n        this.animationTimer = 0;\r\n        this.animationImageSequence = this.animationMsPerImage - 1;\r\n      }\r\n    }\r\n\r\n    this.animationImageTile =\r\n      this.tileset[\r\n        (((this.faceDirection + 2) % 4) * 3) +\r\n        Math.floor(this.animationImageSequence / this.animationMsPerImage) % 3\r\n        ];\r\n\r\n    if(interact) {\r\n      if(this.faceDirection % 2 === 0) {  // Are we facing north or south?\r\n        this.level.playerInteracted(this, this.x, this.y + (this.faceDirection - 1));\r\n      } else {\r\n        this.level.playerInteracted(this, this.x + (this.faceDirection - 2), this.y);\r\n      }\r\n    }\r\n\r\n    if(fire) {\r\n      if(this.faceDirection % 2 === 0) {  // Are we facing north or south?\r\n        this.level.playerFired(this, this.x, this.y + (this.faceDirection - 1));\r\n      } else {\r\n        this.level.playerFired(this, this.x + (this.faceDirection - 2), this.y);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @method\r\n   * Render the player.\r\n   * Draw here as if your visible grid is infinite, scrolling within a viewport is done by the PlanetLevelManager.\r\n   * @param {DOMHighResTimeStamp} elapsedTime - The amount of time elapsed this frame.\r\n   * @param {CanvasRenderingContext2D} context - The rendering context.\r\n   * @param {boolean} isHoldingGun - Whether or not the player should be drawn holding a weapon. Defaults to false if\r\n   * it isn't provided.\r\n   */\r\n  render(elapsedTime, context, isHoldingGun) {\r\n    if(this.imagesLoading === 0) {\r\n      if(isHoldingGun === undefined) {\r\n          isHoldingGun = false;\r\n      }\r\n\r\n      let sourceImage;\r\n      if(isHoldingGun) {\r\n          sourceImage = this.gunImage;\r\n      } else {\r\n          sourceImage = this.noGunImage;\r\n      }\r\n\r\n      context.drawImage(\r\n          sourceImage,\r\n          this.animationImageTile[\"imageX\"],                        // X position within the image\r\n          this.animationImageTile[\"imageY\"],                        // Y position within the image\r\n          32,                                                       // Width of the tile within the image\r\n          32,                                                       // Height of the tile within the image\r\n          (this.x) * 32 + this.animationXOffset,                    // X position within the rendered context\r\n          (this.y) * 32 + this.animationYOffset,                    // Y position within the rendered context\r\n          32,                                                       // Width of the tile within the rendered context\r\n          32);                                                      // Height of the tile within the rendered context\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/PlanetPlayer.js?");

/***/ }),

/***/ "./src/PlanetTileset.js":
/*!******************************!*\
  !*** ./src/PlanetTileset.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PlanetTileset; });\n/**\r\n * Loads a tileset from the Tiled program only.\r\n * Provides rendering logic.\r\n * Provides tile retrieval and property querying.\r\n * If customizing, ensure you don't break any existing functionality (eg, if you're using a tilemap not made in Tiled).\r\n *\r\n * Properties of tiles can be queried easily:\r\n *  if(getTile(10, 5)[\"passable\"]) {...}\r\n * where \"passable\" is a property defined for the tile in Tiled.\r\n *\r\n * Construct with already loaded tileset and tilemaps, and just the path to the image:\r\n *  new PlanetTileset(\r\n *    require('path/to/tileset.json'),\r\n *    require('path/to/tilemap.json'),\r\n *    'path/to/image.png');\r\n *\r\n * See sample planet level for more examples.\r\n */\r\nclass PlanetTileset {\r\n\r\n  /**\r\n   * Create a new planet tileset.\r\n   * @param tilesetJson - Must be an already loaded tileset (defines each tile type).\r\n   * @param tilemapJson - Must be an already loaded tilemap (defines the map using each of the tile types).\r\n   * @param tilesetImageFilePath - Provide the path relative to the dist folder (ie 'resources/...').\r\n   */\r\n  constructor(tilesetJson, tilemapJson, tilesetImageFilePath) {\r\n    this.imageLoaded = false;\r\n    this.tilesetJson = tilesetJson;\r\n\r\n    // Check if the tileset is valid.\r\n    console.assert(\r\n      this.tilesetJson.tilewidth === 32 && this.tilesetJson.tileheight === 32,\r\n      \"A planet tileset json is not using 32x32 tiles! Fix the json in Tiled.\");\r\n\r\n    // Load the tileset image.\r\n    this.tileImage = new Image();\r\n    this.imageLoaded = false;\r\n    this.tileImage.onload = (() => {\r\n      this.imageLoaded = true;\r\n    });\r\n    this.tileImage.src = tilesetImageFilePath;\r\n\r\n    /// Load the tileset. Create an array of properties for each tile type which can be easily queried.\r\n    this.tileset = [];\r\n    for(let i = 0; i < this.tilesetJson.tilecount; i++) {\r\n      let properties = [];\r\n      properties[\"id\"] = i;\r\n      properties[\"imageX\"] = this.tilesetJson.spacing + ((i % this.tilesetJson.columns) * (32 + this.tilesetJson.margin));\r\n      properties[\"imageY\"] = this.tilesetJson.spacing + (Math.floor(i / this.tilesetJson.columns) * (32 + this.tilesetJson.margin));\r\n\r\n      this.tileset[i] = properties;\r\n    }\r\n\r\n    for(let i = 0; i < this.tilesetJson.tiles.length; i++) {\r\n      let jsonProperties = this.tilesetJson.tiles[i].properties;\r\n      let id = this.tilesetJson.tiles[i].id;\r\n      for(let j = 0; j < jsonProperties.length; j++) {\r\n        this.tileset[id][jsonProperties[j].name] = jsonProperties[j].value;\r\n      }\r\n    }\r\n\r\n    // Prepare the tilemap.\r\n    this.loadNewTilemap(tilemapJson);\r\n  }\r\n\r\n  /**\r\n   * Load a new tilemap into this tileset.\r\n   * Overwrites the previous tilemap.\r\n   * @param tilemapJson Loaded tilemap json (created in Tiled.) Use require('path/to/file'). Path is relative to where\r\n   * the require() is used.\r\n   */\r\n  loadNewTilemap(tilemapJson) {\r\n    this.tilemapJson = tilemapJson;\r\n\r\n    // Check if the tilemap is correctly set up. This might not be necessary.\r\n    console.assert(\r\n      this.tilemapJson.renderorder === \"right-down\",\r\n      \"A planet tilemap json is not renderorder exported as 'right-down'! Fix the json in Tiled or manually override the json.\");\r\n\r\n    // Current level width and height (in grid squares) is all defined in the tilemap.json from Tiled.\r\n    this.width = this.tilemapJson.width;\r\n    this.height = this.tilemapJson.height;\r\n    this.numberOfTilesInMap = this.width * this.height;\r\n    this.tilemapOrder = [];\r\n    for(let layerIndex = 0; layerIndex < this.tilemapJson.layers.length; layerIndex++) {\r\n      if(this.tilemapJson.layers[layerIndex].type === \"tilelayer\") {\r\n        this.tilemapOrder.push({\r\n          id: this.tilemapJson.layers[layerIndex].id,\r\n          location: layerIndex\r\n        });\r\n      }\r\n    }\r\n    this.tilemapOrder.sort((a, b) => { return a.id - b.id; });\r\n  }\r\n\r\n  /**\r\n   * Change the tile id from its original value.\r\n   * @param x - X grid coordinate\r\n   * @param y - Y grid coordinate\r\n   * @param layer - Layer of the tile (try 0 or 1 if you aren't using layers)\r\n   * @param id - New id (from your tileset) for the tile.\r\n   */\r\n  setTileId(x, y, layer, id) {\r\n    this.tilemapJson.layers[layer].data[x + (this.tilemapJson.width * y)] = id + 1;\r\n  }\r\n\r\n  /** @method\r\n   * Retrieve the highest layer tile object for a tile at the given coordinates.\r\n   * The y coordinate can be omitted if the tiles are being indexed by a single dimension.\r\n   * @param x - X grid coordinate for the requested tile.\r\n   * @param y - Y grid coordinate for the requested tile.\r\n   * @returns An array of properties defined by that tile, including imageX, imageY, and id, as well as other custom\r\n   * properties defined in Tiled. The highest layer with an actual tile in this location is returned.\r\n   */\r\n  getTile(x, y) {\r\n    if(y === undefined) {\r\n      y = 0;\r\n    }\r\n\r\n    let highestTile = undefined;\r\n    this.getStackedTiles(x, y).reverse().some((value) => {\r\n      if(value !== undefined) {\r\n        highestTile = value;\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n    return highestTile;\r\n  }\r\n\r\n  /** @method\r\n   * Retrieves all tiles at the given coordinates (if using multiple layers in Tiled).\r\n   * THe y coordinate can be omitted if the tiles are being index by a single dimension.\r\n   * @param x - X grid coordinate to retrieve from.\r\n   * @param y - Y grid coordinate to retrieve from.\r\n   * @returns {array} List of tiles for the provided coordinates where the \"key\" or index for each item is the layer id\r\n   * that the tile is found on.\r\n   * NOTE: Layer ID's start from 1 in Tiled, not 0! Requesting the 0 index will return undefined for this array.\r\n   */\r\n  getStackedTiles(x, y) {\r\n    if(y === undefined) {\r\n      y = 0;\r\n    }\r\n\r\n    let tiles = [];\r\n    for(let i = 0; i < this.tilemapOrder.length; i++) {\r\n      let layerIndex = this.tilemapOrder[i].location;\r\n\r\n      // We must take the tile id - 1 here because the 0 id within **tilemaps** is reserved for undefined tiles (as\r\n      // per Tiled standard). The id of each tile returned should be what we'd normally expect.\r\n      // Other than this fix, the id's work as expected.\r\n      let tileId = this.tilemapJson.layers[layerIndex].data[x + (this.tilemapJson.width * y)] - 1;\r\n\r\n      // -1 refers to undefined (unspecified) tiles in this layer.\r\n      if(tileId !== -1) {\r\n        // For some reason Tiled may \"wrap\" the tileId to be realId + (n * tilesetCount)\r\n        // To get the actual tile, we mod the tilecount.\r\n        tiles[this.tilemapJson.layers[layerIndex].id] = this.tileset[tileId % this.tilesetJson.tilecount];\r\n      }\r\n    }\r\n    return tiles;\r\n  }\r\n\r\n  /**\r\n   * Draw a specific tile from your tileset.\r\n   * @param x - X grid coordinate to draw the tile\r\n   * @param y - Y grid coordinate to draw the tile\r\n   * @param id - Id of the tile (from your tileset) to draw\r\n   * @param context - Drawing context\r\n   */\r\n  drawTile(x, y, id, context) {\r\n    let tile = this.tileset[id];\r\n    context.drawImage(\r\n      this.tileImage,\r\n      tile[\"imageX\"],                                           // X position within the image\r\n      tile[\"imageY\"],                                           // Y position within the image\r\n      32,                                                       // Width of the tile within the image\r\n      32,                                                       // Height of the tile within the image\r\n      x * 32,             // X position within the rendered context\r\n      y * 32,   // Y position within the rendered context\r\n      32,                                                       // Width of the tile within the rendered context\r\n      32);                                                      // Height of the tile within the rendered context\r\n  }\r\n\r\n\r\n  /** @method\r\n   * Render the tileset.\r\n   * Draw here as if your visible grid is infinite, scrolling within a viewport is done by the PlanetLevelManager.\r\n   * @param {DOMHighResTimeStamp} elapsedTime - the amount of time elapsed this frame\r\n   * @param {CanvasRenderingContext2D} context - the rendering context\r\n   */\r\n  render(elapsedTime, context) {\r\n    if(this.imageLoaded) {\r\n      // We don't use the getStackedTiles function here primarily for efficiency.\r\n      // We want to draw each layer in order, then go to the next layer (instead of tile by tile) to avoid cache miss.\r\n\r\n      // Draw each layer\r\n      for(let i = 0; i < this.tilemapOrder.length; i++) {\r\n        let layerIndex = this.tilemapOrder[i].location;\r\n        // Draw each tile\r\n        for(let tilemapIndex = 0; tilemapIndex < this.numberOfTilesInMap; tilemapIndex++) {\r\n          // Only draw the tile if the tile exists\r\n          // Non-existent tiles in a layer are 0 in JSON with each tile id for every other tile incremented by one\r\n          // We subtract 1 here to offset this, so -1 is non-existent and 0 and above is the actual tile id.\r\n          let tileId = this.tilemapJson.layers[layerIndex].data[tilemapIndex] - 1;\r\n          if(tileId !== -1) {\r\n            // For some reason Tiled may \"wrap\" the tileId to be realId + (n * tilesetCount)\r\n            // To get the actual tile, we mod the tilecount.\r\n            let tile = this.tileset[tileId % this.tilesetJson.tilecount];\r\n            context.drawImage(\r\n              this.tileImage,\r\n              tile[\"imageX\"],                                           // X position within the image\r\n              tile[\"imageY\"],                                           // Y position within the image\r\n              32,                                                       // Width of the tile within the image\r\n              32,                                                       // Height of the tile within the image\r\n              (tilemapIndex % this.tilemapJson.width) * 32,             // X position within the rendered context\r\n              Math.floor(tilemapIndex / this.tilemapJson.width) * 32,   // Y position within the rendered context\r\n              32,                                                       // Width of the tile within the rendered context\r\n              32);                                                      // Height of the tile within the rendered context\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/PlanetTileset.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ \"./src/input.js\");\n/* harmony import */ var _menus_start_screen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./menus/start-screen */ \"./src/menus/start-screen.js\");\n\r\n\r\n\r\n/** @class Game\r\n  * A class representing the high-level functionality\r\n  * of a game - the game loop, buffer swapping, etc.\r\n  */\r\nclass Game {\r\n  /** @constructor\r\n    * Creates the game instance\r\n    * @param {int} width - the width of the game screen in pixels\r\n    * @param {int} height - the height of the game screen in pixels\r\n    */\r\n  constructor(width, height) {\r\n    this._start = null;\r\n    this.WIDTH = width;\r\n    this.HEIGHT = height;\r\n    this.GRID_WIDTH = Math.floor(width / 32);\r\n    this.GRID_HEIGHT = Math.floor(height / 32);\r\n\r\n    // Set up the back buffer\r\n    this.backBuffer = document.createElement('canvas');\r\n    this.backBuffer.width = this.WIDTH;\r\n    this.backBuffer.height = this.HEIGHT;\r\n    this.backBufferCtx = this.backBuffer.getContext('2d');\r\n\r\n    // Set up the screen buffer\r\n    this.screenBuffer = document.createElement('canvas');\r\n    this.screenBuffer.width = this.WIDTH;\r\n    this.screenBuffer.height = this.HEIGHT;\r\n    this.screenBufferCtx = this.screenBuffer.getContext('2d');\r\n    document.body.append(this.screenBuffer);\r\n\r\n    // Set up the input object\r\n    this.input = new _input__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n\r\n    // Set up the game state stack\r\n    this.gameState = []\r\n    this.gameState.push(new _menus_start_screen__WEBPACK_IMPORTED_MODULE_1__[\"default\"]());\r\n  }\r\n  /** @method pushGameState\r\n    * Pushes the provided game state to the\r\n    * state stack.\r\n    * @param {GameState} gameState - an object that\r\n    * implements an update() and render() method.\r\n    */\r\n  pushGameState(gameState) {\r\n    this.gameState.push(gameState);\r\n  }\r\n  /** @method popGameState\r\n    * Pops the current game state from the state stack.\r\n    * @return {GameState} the popped game state object\r\n    */\r\n  popGameState() {\r\n    return this.gameState.pop();\r\n  }\r\n  /** @method update\r\n    * Updates the game state\r\n    * @param {integer} elapsedTime - the number of milliseconds per frame\r\n    */\r\n  update(elapsedTime) {\r\n    // Update the active game state\r\n    this.gameState[this.gameState.length - 1].update(elapsedTime, this.input, this);\r\n\r\n    // Update the input object\r\n    this.input.update();\r\n  }\r\n  /** @method render\r\n    * Renders the game state\r\n    * @param {integer} elapsedTime - the number of milliseconds per frame\r\n    */\r\n  render(elapsedTime) {\r\n    // Clear the back buffer\r\n    this.backBufferCtx.fillStyle = \"#000\";\r\n    this.backBufferCtx.fillRect(0,0,this.WIDTH, this.HEIGHT);\r\n\r\n    // Render the game state\r\n    this.gameState[this.gameState.length - 1].render(elapsedTime, this.backBufferCtx, this);\r\n\r\n    // Flip the back buffer\r\n    this.screenBufferCtx.drawImage(this.backBuffer, 0, 0);\r\n  }\r\n  /** @method loop\r\n    * Updates and renders the game,\r\n    * and calls itself on the next draw cycle.\r\n    * @param {DOMHighResTimestamp} timestamp - the current system time\r\n    */\r\n  loop(timestamp) {\r\n    var elapsedTime = this._frame_start ? timestamp - this._frame_start : 0;\r\n    this.update(elapsedTime);\r\n    this.render(elapsedTime);\r\n    this._frame_start = timestamp;\r\n    window.requestAnimationFrame((timestamp) => {this.loop(timestamp)});\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./index.css */ \"./node_modules/css-loader/index.js!./src/index.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/index.css?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.js\");\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_css__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nvar game = new _game__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((32*32), (24*32)); //1024 x 768 (could be changed as long as factor of 32)\r\ngame.loop();\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/input.js":
/*!**********************!*\
  !*** ./src/input.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Input; });\n\r\n/** @module Input\r\n  * A class for handling input from the user\r\n  * will work for all keys on the keyboard\r\n  */\r\nclass Input {\r\n  /** @constructor\r\n    * Constructs a new instance of the Input class\r\n    * and attaches event listeners to the window.\r\n    */\r\n  constructor() {\r\n    this.oldState = {};\r\n    this.newState = {};\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      if(event.key.length <= 1 || event.key.charAt(0) !== 'F') {\r\n        event.preventDefault();\r\n      }\r\n      this.newState[event.key] = true;\r\n    });\r\n\r\n    window.addEventListener('keyup', (event) => {\r\n      if(event.key.length <= 1 || event.key.charAt(0) !== 'F') {\r\n        event.preventDefault();\r\n      }\r\n      this.newState[event.key] = false;\r\n    });\r\n\r\n  }\r\n\r\n  /** @method\r\n    * Copies the new state to the old state\r\n    */\r\n  update() {\r\n    this.oldState = JSON.parse(JSON.stringify(this.newState));\r\n  }\r\n\r\n  /** @method\r\n    * Returns true if the specified key is\r\n    * currently pressed.\r\n    * @param {String} key - the key to test\r\n    * @return {bool} if the key is pressed\r\n    */\r\n  keyPressed(key) {\r\n    return this.newState[key];\r\n  }\r\n\r\n  /** @method\r\n    * Returns true if the specified key\r\n    * went down this frame\r\n    * @param {String} key - the key to test\r\n    * @return {bool} if the key is pressed\r\n    */\r\n  keyDown(key) {\r\n    return this.newState[key] && !this.oldState[key];\r\n  }\r\n\r\n  /** @method\r\n    * Returns true if the specified key\r\n    * went up this frame\r\n    * @param {String} key - the key to test\r\n    * @return {bool} if the key is pressed\r\n    */\r\n  keyUp(key) {\r\n    return !this.newState[key] && this.oldState[key];\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/input.js?");

/***/ }),

/***/ "./src/menus/PlanetLevelManager.js":
/*!*****************************************!*\
  !*** ./src/menus/PlanetLevelManager.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PlanetLevelManager; });\n/* harmony import */ var _PlanetPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PlanetPlayer */ \"./src/PlanetPlayer.js\");\n\r\n\r\n/**\r\n * Manages a planet level and provides scrolling functionality.\r\n * Changes to this class will affect every other planet level.\r\n */\r\nclass PlanetLevelManager {\r\n\r\n  /**\r\n   * Create a new manager to work with the given level.\r\n   * Typically should be called like:\r\n   *   new PlanetLevelManager(new SamplePlanetLevel());\r\n   * @param level - The level to manager and call render/update functions for.\r\n   */\r\n  constructor(level) {\r\n    this.finished = false;\r\n\r\n    this.level = level;\r\n    this.player = new _PlanetPlayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.level);\r\n    this.lastCalculatedTilemapWidth = 0;\r\n    this.lastCalculatedTilemapHeight = 0;\r\n\r\n    this.scrollingXOffset = 0;\r\n    this.scrollingYOffset = 0;\r\n\r\n    this.scrollingCanvas = document.createElement('canvas');\r\n    this.scrollingCanvas.width = this.level.tileset.width * 32;\r\n    this.scrollingCanvas.height = this.level.tileset.height * 32;\r\n    this.scrollingContext = this.scrollingCanvas.getContext('2d');\r\n  }\r\n\r\n  /**\r\n   * Get the active level.\r\n   * Used externally.\r\n   * @returns {BasePlanetLevel} An extension of the BasePlanetLevel representing the current custom planet level.\r\n   */\r\n  getLevel() {\r\n    return this.level;\r\n  }\r\n\r\n  /**\r\n   * Get the icon (treasure token) for the current level.\r\n   * Used externally.\r\n   * @returns {Image} Drawable image.\r\n   */\r\n  getLevelIcon() {\r\n    return this.level.icon;\r\n  }\r\n\r\n  /**\r\n   * Get the name of the current level.\r\n   * Used externally.\r\n   * @returns {string}\r\n   */\r\n  getLevelName() {\r\n    return this.level.name;\r\n  }\r\n\r\n  /**\r\n   * Check whether or not the current level is finished.\r\n   * Used externally.\r\n   * Typically rendering and updating of this manager should stop once this is true.\r\n   * @returns {boolean} True if finished, false if the player is still playing.\r\n   */\r\n  levelFinished() {\r\n    return this.finished;\r\n  }\r\n\r\n  /**\r\n   * Check whether or not the player succeeded in gaining the treasure for this active level.\r\n   * Used externally.\r\n   * Typically this should only be checked once levelFinished() is true.\r\n   * @returns {boolean} True if success, false if failure (no treasure).\r\n   */\r\n  playerSucceeded() {\r\n    return this.level.success;\r\n  }\r\n\r\n  /** @method\r\n   * Updates the active level and any calculations necessary for tileset scrolling.\r\n   * @param {DOMHighResTimeStamp} elaspedTime - The amount of time elapsed this frame.\r\n   * @param {Input} input - The input from this and the prior frame.\r\n   * @param {Game} game - The game object.\r\n   */\r\n  update(elaspedTime, input, game) {\r\n    if(this.level.finished) {\r\n      this.finished = true;\r\n    } else {\r\n      this.level.update(elaspedTime, input, game, this.player);\r\n\r\n      // Check if we need to update our scrolling information based on a change in tilemap.\r\n      if(this.lastCalculatedTilemapWidth !== this.level.tileset.width ||\r\n          this.lastCalculatedTilemapHeight !== this.level.tileset.height) {\r\n\r\n        this.lastCalculatedTilemapWidth = this.level.tileset.width;\r\n        this.lastCalculatedTilemapHeight = this.level.tileset.height;\r\n\r\n        // Edges which, if the player is within, the map must scroll.\r\n        this.leftEdge = game.WIDTH / (32 * 2);\r\n        this.topEdge = game.HEIGHT / (32 * 2);\r\n        this.rightEdge = this.lastCalculatedTilemapWidth - (this.leftEdge);\r\n        this.bottomEdge = this.lastCalculatedTilemapHeight - (this.topEdge);\r\n\r\n        // Actual dimensions that we'll be drawing. Either the dim of the canvas or the tilemap dim, whichever is smaller.\r\n        this.drawingWidth = Math.min(game.WIDTH, this.lastCalculatedTilemapWidth * 32);\r\n        this.drawingHeight = Math.min(game.HEIGHT, this.lastCalculatedTilemapHeight * 32);\r\n\r\n        // Update the scrolling canvas with the new width and height.\r\n        this.scrollingCanvas.width = this.lastCalculatedTilemapWidth * 32;\r\n        this.scrollingCanvas.height = this.lastCalculatedTilemapHeight * 32;\r\n\r\n        // If the new tilemap is smaller, we want to avoid drawing old data.\r\n        this.scrollingContext.clearRect(0, 0, this.scrollingCanvas.width, this.scrollingCanvas.height);\r\n      }\r\n\r\n      let animationAdjustedPlayerX = this.player.x + (this.player.animationXOffset / 32);\r\n      // Check if we need to scroll x dimension.\r\n      if(this.lastCalculatedTilemapWidth > game.GRID_WIDTH && animationAdjustedPlayerX > this.leftEdge) {\r\n        if(animationAdjustedPlayerX < this.rightEdge) {\r\n          this.scrollingXOffset = (this.player.x - this.leftEdge) * 32 + this.player.animationXOffset;\r\n        } else {\r\n          this.scrollingXOffset = (this.rightEdge - this.leftEdge) * 32;\r\n        }\r\n      } else {\r\n        this.scrollingXOffset = 0;\r\n      }\r\n\r\n      let animationAdjustedPlayerY = this.player.y + (this.player.animationYOffset / 32);\r\n      // Check if we need to scroll y dimension.\r\n      if(this.lastCalculatedTilemapHeight > game.GRID_HEIGHT && animationAdjustedPlayerY > this.topEdge) {\r\n        if(animationAdjustedPlayerY < this.bottomEdge) {\r\n          this.scrollingYOffset = (this.player.y - this.topEdge) * 32 + this.player.animationYOffset;\r\n        } else {\r\n          this.scrollingYOffset = (this.bottomEdge - this.topEdge) * 32;\r\n        }\r\n      } else {\r\n        this.scrollingYOffset = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @method\r\n   * Renders the active level and manages tileset scrolling within the scene.\r\n   * @param {DOMHighResTimeStamp} elapsedTime - The amount of time elapsed this frame.\r\n   * @param {CanvasRenderingContext2D} context - The rendering context.\r\n   */\r\n  render(elapsedTime, context) {\r\n    if(!this.finished) {\r\n      this.level.render(elapsedTime, this.scrollingContext, this.player);\r\n\r\n      context.drawImage(\r\n        this.scrollingCanvas,\r\n        this.scrollingXOffset,\r\n        this.scrollingYOffset,\r\n        this.drawingWidth,\r\n        this.drawingHeight,\r\n        0,\r\n        0,\r\n        this.drawingWidth,\r\n        this.drawingHeight);\r\n\r\n      this.level.renderStatic(elapsedTime, context, this.player);\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/menus/PlanetLevelManager.js?");

/***/ }),

/***/ "./src/menus/start-screen.js":
/*!***********************************!*\
  !*** ./src/menus/start-screen.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StartScreen; });\n/* harmony import */ var _PlanetLevelManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlanetLevelManager */ \"./src/menus/PlanetLevelManager.js\");\n/* harmony import */ var _planet_levels_SamplePlanetLevel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planet_levels/SamplePlanetLevel */ \"./src/planet_levels/SamplePlanetLevel.js\");\n/** @class StartScreen\r\n  * A starting screen for the game.\r\n  */\r\n\r\n\r\n\r\nclass StartScreen {\r\n  /** @method\r\n    * Updates the starting screen\r\n    * @param {DOMHighResTimeStamp} elaspedTime - the amount of time elapsed this frame\r\n    * @param {Input} input - the input from this and the prior frame\r\n    * @param {Game} game - the game object\r\n    */\r\n  update(elaspedTime, input, game) {\r\n    // TODO: Load inital game state object\r\n    if(input.keyPressed(' ')) {\r\n      game.pushGameState(new _PlanetLevelManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new _planet_levels_SamplePlanetLevel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()));;\r\n    }\r\n  }\r\n  /** @method\r\n    * Renders the starting screen.\r\n    * @param {DOMHighResTimeStamp} elapsedTime - the amount of time elapsed this frame\r\n    * @param {CanvasRenderingContext2D} context - the rendering context\r\n    */\r\n  render(elapsedTime, context) {\r\n    context.save();\r\n    context.fillStyle = 'white';\r\n    context.font = '48pt Serif';\r\n    context.fillText(\"Welcome to Space Raiders\", 280, 200);\r\n    context.font = '18pt Serif';\r\n    context.fillText(\"Press [SPACE] to Begin\", 500, 300);\r\n    context.restore();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/menus/start-screen.js?");

/***/ }),

/***/ "./src/planet_levels/BasePlanetLevel.js":
/*!**********************************************!*\
  !*** ./src/planet_levels/BasePlanetLevel.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BasePlanetLevel; });\n/**\r\n * Base level class used to provide basic functionality and structure for each level.\r\n * This class could be customized, but you should typically put any level-specific functionality in your own copy of the\r\n * sample planet level.\r\n *\r\n * ** Modification to this class may affect all other planet levels. **\r\n *\r\n * Each planet should extend this class, and call the super() function to call this constructor.\r\n */\r\nclass BasePlanetLevel {\r\n\r\n  /**\r\n   * Should be called by the extending levels when constructed using the super() call.\r\n   * Might overwrite some customization if it is not the first call in the planet's constructor.\r\n   */\r\n  constructor() {\r\n    this.finished = false;\r\n    this.success = false;\r\n\r\n    this.playerSpawnX = 1;\r\n    this.playerSpawnY = 1;\r\n    this.playerSpawnFaceDirection = 1;\r\n\r\n    this.tileset = undefined;\r\n    this.icon = new Image(32, 32);\r\n    this.name = \"Base Planet Level\";\r\n  }\r\n\r\n  /** @method\r\n   * Called when the player interacts with a tile.\r\n   * @param player Representation of the player.\r\n   * @param x X grid coordinate of the interacted tile (in front of player).\r\n   * @param y Y grid coordinate of the interacted tile (in front of player).\r\n   */\r\n  playerInteracted(player, x, y) {}\r\n\r\n  /**\r\n   * Called when the player moves.\r\n   * @param player Representation of the player.\r\n   */\r\n  playerMoved(player) {}\r\n\r\n  /**\r\n   * Called when the player fires a weapon.\r\n   * @param player Representation of the player.\r\n   * @param x X grid coordinate of the tile the player fires into (in front of player).\r\n   * @param y Y grid coordinate of the tile the player fires into (in front of player).\r\n   */\r\n  playerFired(player, x, y) {}\r\n\r\n  /**\r\n   * Called when the player attempts to move into tile at the given coordinates.\r\n   * @param x The X coordinate of the attempted move.\r\n   * @param y The Y coordinate of the attempted move.\r\n   * @return True if the player may pass, false if the requested tile is \"blocked\".\r\n   */\r\n  tilePassable(x, y) {}\r\n\r\n  /** @method\r\n   * Update any entities within this planet level, including the player.\r\n   * @param {DOMHighResTimeStamp} elaspedTime - the amount of time elapsed this frame\r\n   * @param {Input} input - the input from this and the prior frame\r\n   * @param {Game} game - the game object\r\n   * @param {PlanetPlayer} player - representation of the player\r\n   */\r\n  update(elaspedTime, input, game, player) {}\r\n\r\n  /** @method\r\n   * Render the tileset, the player, and any other custom entities to the provided context.\r\n   * Draw here as if your visible grid is infinite, scrolling within a viewport is done by the PlanetLevelManager.\r\n   * @param {DOMHighResTimeStamp} elapsedTime - the amount of time elapsed this frame\r\n   * @param {CanvasRenderingContext2D} context - the rendering context\r\n   * @param {PlanetPlayer} player - representation of the player\r\n   */\r\n  render(elapsedTime, context, player) {}\r\n\r\n  /** @method\r\n   * Draw text using the static context (after scrolling).\r\n   * Only use this for drawing items on top of the screen.\r\n   * @param staticContext - The context to draw on top of the screen and scrolling elements.\r\n   */\r\n  renderStatic(elapsedTime, staticContext, player) {}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/planet_levels/BasePlanetLevel.js?");

/***/ }),

/***/ "./src/planet_levels/SamplePlanetLevel.js":
/*!************************************************!*\
  !*** ./src/planet_levels/SamplePlanetLevel.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SamplePlanetLevel; });\n/* harmony import */ var _BasePlanetLevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BasePlanetLevel */ \"./src/planet_levels/BasePlanetLevel.js\");\n/* harmony import */ var _PlanetTileset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PlanetTileset */ \"./src/PlanetTileset.js\");\n\r\n\r\n\r\n/**\r\n * Example SamplePlanetLevel which extends the base planet class functionality.\r\n * ** DO NOT MODIFY THIS CLASS. **\r\n *\r\n * To start your own planet, copy this file and rename the class to your own level name, then customize the various\r\n * methods to tailor it to your game.\r\n */\r\nclass SamplePlanetLevel extends _BasePlanetLevel__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\r\n  /**\r\n   * Called when the level is being created.\r\n   * Be sure to call super() first (before anything else) to ensure the basic planet structure is in place.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    this.playerSpawnX = 10;\r\n    this.playerSpawnY = 10;\r\n    this.playerSpawnFaceDirection = 1;\r\n\r\n    // This loads your own tileset created from Tiled.\r\n    // You'll need the tileset.json, tilemap.json, and image.png. Look at the PlanetTileset class for more details.\r\n\r\n    // First two arguments (tileset and tilemap) are relative to the current folder (wherever this file is).\r\n    // Third argument (image) is relative to the dist folder.\r\n    this.tileset = new _PlanetTileset__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\r\n      __webpack_require__(/*! ../../dist/resources/planet_tilesets/sample_planet_level/tileset.json */ \"./dist/resources/planet_tilesets/sample_planet_level/tileset.json\"),\r\n      __webpack_require__(/*! ../../dist/resources/planet_tilesets/sample_planet_level/tilemap.json */ \"./dist/resources/planet_tilesets/sample_planet_level/tilemap.json\"),\r\n      \"resources/planet_tilesets/sample_planet_level/tiles.png\");\r\n\r\n    this.icon = new Image(32, 32);  // Could be taken from your tileset, this is just a sample blank image.\r\n    this.name = \"Sample Planet Level\";\r\n\r\n    //TO DISPLAY TEXT ADD THIS TO YOUR CLASS\r\n    //You'll have changes in playerInteracted, tilePassable, and renderStatic.\r\n    //MAKE SURE YOU GET THEM ALL \r\n    //If you need more reference, feel free to look at the implementation in LizardJungleLevel\r\n    this.message = [];\r\n    this.message.push('starting text');\r\n    //push each line individually\r\n    //you'll have to check if something goes off the screen and adjust for that by breaking\r\n    //it into multiple push statements\r\n  }\r\n\r\n  /** @method\r\n   * Called when the player interacts with a tile.\r\n   * @param player Representation of the player.\r\n   * @param x X grid coordinate of the interacted tile (in front of player).\r\n   * @param y Y grid coordinate of the interacted tile (in front of player).\r\n   */\r\n  playerInteracted(player, x, y) {\r\n    console.log(\"Player interacted with \" + x + \",\" + y);\r\n\r\n    //This code handles interacting with things and properly clearing the box\r\n    //I would suggest copying this exactly and then changing the if to whatever you need\r\n    var message = '';\r\n    if (x == 5) {\r\n      message = \"wow!\";\r\n    }\r\n    if (this.message.length !== 0 && message !== '') this.message.length = 0;\r\n    else if (message === '') {\r\n      this.message.length = 0;\r\n    }\r\n    else this.message.push(message);\r\n\r\n    // if(this.map === undefined) {\r\n    //   this.map = 0;\r\n    // }\r\n    // this.map++;\r\n    // this.map %= 3;\r\n    // switch(this.map) {\r\n    //   case 0:\r\n    //     this.tileset.loadNewTilemap(require(\"../../dist/resources/planet_tilesets/sample_planet_level/tilemap.json\"));\r\n    //     break;\r\n    //   case 1:\r\n    //     this.tileset.loadNewTilemap(require(\"../../dist/resources/planet_tilesets/sample_planet_level/tilemap_large.json\"));\r\n    //     break;\r\n    //   case 2:\r\n    //     this.tileset.loadNewTilemap(require(\"../../dist/resources/planet_tilesets/sample_planet_level/tilemap_small.json\"));\r\n    //     break;\r\n    // }\r\n    // player.movePlayerToSpawn();\r\n  }\r\n\r\n  /**\r\n   * Called when the player moves.\r\n   * @param player Representation of the player.\r\n   */\r\n  playerMoved(player) {\r\n    console.log(\"Player at \" + player.x + \",\" + player.y);\r\n  }\r\n\r\n  /**\r\n   * Called when the player fires a weapon.\r\n   * @param player Representation of the player.\r\n   * @param x X grid coordinate of the tile the player fires into (in front of player).\r\n   * @param y Y grid coordinate of the tile the player fires into (in front of player).\r\n   */\r\n  playerFired(player, x, y) {\r\n    console.log(\"Player fired at \" + x + \",\" + y);\r\n  }\r\n\r\n  /**\r\n   * Called when the player attempts to move into tile at the given coordinates.\r\n   * @param x The X coordinate of the attempted move.\r\n   * @param y The Y coordinate of the attempted move.\r\n   * @return True if the player may pass, false if the requested tile is \"blocked\".\r\n   */\r\n  tilePassable(x, y) {\r\n    if (this.message.length > 0) return false; //Add this line so you can't move when the text box is there\r\n    return this.tileset.getTile(x, y)[\"passable\"] === true;\r\n  }\r\n\r\n  /** @method\r\n   * Update any entities within this planet level, including the player.\r\n   * @param {DOMHighResTimeStamp} elaspedTime - the amount of time elapsed this frame\r\n   * @param {Input} input - the input from this and the prior frame\r\n   * @param {Game} game - the game object\r\n   * @param {PlanetPlayer} player - representation of the player\r\n   */\r\n  update(elaspedTime, input, game, player) {\r\n    player.update(elaspedTime, input, game);\r\n  }\r\n\r\n  /** @method\r\n   * Render the tileset, the player, and any other custom entities to the provided context.\r\n   * Draw here as if your visible grid is infinite, scrolling within a viewport is done by the PlanetLevelManager.\r\n   * @param {DOMHighResTimeStamp} elapsedTime - the amount of time elapsed this frame\r\n   * @param {CanvasRenderingContext2D} context - the rendering context\r\n   * @param {PlanetPlayer} player - representation of the player\r\n   */\r\n  render(elapsedTime, context, player) {\r\n    this.tileset.render(elapsedTime, context);\r\n    player.render(elapsedTime, context);\r\n  }\r\n\r\n  /** @method\r\n   * Draw items using the static context (after scrolling).\r\n   * Only use this for drawing items on top of the screen.\r\n   * @param staticContext - The context to draw on top of the screen and scrolling elements.\r\n   */\r\n  renderStatic(elapsedTime, staticContext, player) {\r\n    //just copy and paste all of this\r\n      if (this.message.length > 0) {\r\n        staticContext.fillStyle = 'white';\r\n        staticContext.fillRect(0, 576, 1024, 256);\r\n        staticContext.fillStyle = 'black';\r\n        staticContext.font = '24px Arial';\r\n        for (var i = 0; i < this.message.length; i++) {\r\n          staticContext.fillText(this.message[i], 60, 630+40*i);\r\n        }\r\n        staticContext.font = '18px Arial';\r\n        staticContext.fillText('Press F to continue', 800, 730);\r\n      }\r\n      else {\r\n        staticContext.fillStyle = 'transparent';\r\n      }\r\n    }\r\n  }\r\n\n\n//# sourceURL=webpack:///./src/planet_levels/SamplePlanetLevel.js?");

/***/ })

/******/ });